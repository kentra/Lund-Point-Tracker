<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Star Realms Point Tracker</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üöÄ</text></svg>">
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const STARTING_AUTHORITY = 50;
        const STORAGE_KEY = 'starRealmsTracker';

        function App() {
            const [player1Authority, setPlayer1Authority] = useState(STARTING_AUTHORITY);
            const [player2Authority, setPlayer2Authority] = useState(STARTING_AUTHORITY);
            const [player1Score, setPlayer1Score] = useState(0);
            const [player2Score, setPlayer2Score] = useState(0);
            const [player1Name, setPlayer1Name] = useState('Player 1');
            const [player2Name, setPlayer2Name] = useState('Player 2');
            const [player1Rotation, setPlayer1Rotation] = useState(0);
            const [player2Rotation, setPlayer2Rotation] = useState(0);
            const [gameHistory, setGameHistory] = useState([]);
            const [gameOver, setGameOver] = useState(false);
            const [tableMode, setTableMode] = useState(false);
            const [showMenu, setShowMenu] = useState(false);
            const [winner, setWinner] = useState(null);
            const [winnerAuthority, setWinnerAuthority] = useState(0);
            const [videoKey, setVideoKey] = useState(0);
            const [showVideo, setShowVideo] = useState(false);
            const [lastMatchSummary, setLastMatchSummary] = useState('');
            const [player1HighestDamage, setPlayer1HighestDamage] = useState(0);
            const [player2HighestDamage, setPlayer2HighestDamage] = useState(0);
            const [player1HighestHeal, setPlayer1HighestHeal] = useState(0);
            const [player2HighestHeal, setPlayer2HighestHeal] = useState(0);
            const [gameStartTime, setGameStartTime] = useState(null);
            const [lastPlayer, setLastPlayer] = useState(0);
            const [player1CurrentTurnDamage, setPlayer1CurrentTurnDamage] = useState(0);
            const [player2CurrentTurnDamage, setPlayer2CurrentTurnDamage] = useState(0);
            const [player1CurrentTurnHeal, setPlayer1CurrentTurnHeal] = useState(0);
            const [player2CurrentTurnHeal, setPlayer2CurrentTurnHeal] = useState(0);
            const [player1HighestTurnDamage, setPlayer1HighestTurnDamage] = useState(0);
            const [player2HighestTurnDamage, setPlayer2HighestTurnDamage] = useState(0);
            const [player1HighestTurnHeal, setPlayer1HighestTurnHeal] = useState(0);
            const [player2HighestTurnHeal, setPlayer2HighestTurnHeal] = useState(0);
            const [player1Shields, setPlayer1Shields] = useState([0, 0, 0, 0]);
            const [player2Shields, setPlayer2Shields] = useState([0, 0, 0, 0]);
            const [player1ActiveShields, setPlayer1ActiveShields] = useState([false, false, false, false]);
            const [player2ActiveShields, setPlayer2ActiveShields] = useState([false, false, false, false]);
            const [player1PendingDamage, setPlayer1PendingDamage] = useState(0);
            const [player2PendingDamage, setPlayer2PendingDamage] = useState(0);
            const [player1PendingHeal, setPlayer1PendingHeal] = useState(0);
            const [player2PendingHeal, setPlayer2PendingHeal] = useState(0);

            const player1TimerRef = useRef(null);
            const player2TimerRef = useRef(null);

            const audioCtxRef = useRef(null);
            const newGameAudioRef = useRef(null);
            const minusOneSoundRef = useRef(null);
            const minusFiveSoundRef = useRef(null);
            const minusTenSoundRef = useRef(null);
            const minusTwentySoundRef = useRef(null);
            const plusOneSoundRef = useRef(null);
            const plusFiveFirstSoundRef = useRef(null);
            const plusFiveSecondSoundRef = useRef(null);
            const getAudioCtx = () => {
                if (!audioCtxRef.current) {
                    audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                return audioCtxRef.current;
            };

            function playLaserSound(amount) {
                if (amount === -1 && minusOneSoundRef.current) {
                    minusOneSoundRef.current.currentTime = 0;
                    minusOneSoundRef.current.play();
                    return;
                }
                if (amount === -5 && minusFiveSoundRef.current) {
                    minusFiveSoundRef.current.currentTime = 0;
                    minusFiveSoundRef.current.play();
                    return;
                }
                if (amount === -10 && minusTenSoundRef.current) {
                    minusTenSoundRef.current.currentTime = 0;
                    minusTenSoundRef.current.play();
                    return;
                }
                if (amount === -20 && minusTwentySoundRef.current) {
                    minusTwentySoundRef.current.currentTime = 0;
                    minusTwentySoundRef.current.play();
                    setTimeout(() => {
                        minusTwentySoundRef.current.currentTime = 0;
                        minusTwentySoundRef.current.play();
                    }, 100);
                    return;
                }
                
                const audioCtx = getAudioCtx();
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                
                const intensity = Math.abs(amount);
                const baseFreq = 1200 - (intensity * 30);
                const duration = 0.1 + (intensity * 0.005);
                
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(baseFreq, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + duration);
                
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + duration);
            }

            function playWorkshopSound(amount) {
                if (amount === 1 && plusOneSoundRef.current) {
                    plusOneSoundRef.current.currentTime = 0;
                    plusOneSoundRef.current.play();
                    return;
                }
                if (amount === 5 && plusFiveFirstSoundRef.current && plusFiveSecondSoundRef.current) {
                    plusFiveFirstSoundRef.current.currentTime = 0;
                    plusFiveFirstSoundRef.current.play();
                    plusFiveFirstSoundRef.current.onended = function() {
                        plusFiveSecondSoundRef.current.currentTime = 0;
                        plusFiveSecondSoundRef.current.play();
                    };
                    return;
                }
                
                const audioCtx = getAudioCtx();
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                
                const isBig = amount >= 5;
                const duration = isBig ? 0.4 : 0.25;
                const clankDelay = isBig ? 0.08 : 0.05;
                
                const motorOsc = audioCtx.createOscillator();
                const motorGain = audioCtx.createGain();
                motorOsc.type = 'sine';
                motorOsc.frequency.setValueAtTime(80, audioCtx.currentTime);
                motorOsc.frequency.linearRampToValueAtTime(60, audioCtx.currentTime + duration);
                motorGain.gain.setValueAtTime(0.25, audioCtx.currentTime);
                motorGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);
                
                motorOsc.connect(motorGain);
                motorGain.connect(audioCtx.destination);
                
                const clankOsc = audioCtx.createOscillator();
                const clankGain = audioCtx.createGain();
                clankOsc.type = 'square';
                clankOsc.frequency.setValueAtTime(300 + Math.random() * 100, audioCtx.currentTime + clankDelay);
                clankGain.gain.setValueAtTime(0.15, audioCtx.currentTime + clankDelay);
                clankGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + clankDelay + 0.08);
                
                clankOsc.connect(clankGain);
                clankGain.connect(audioCtx.destination);
                
                motorOsc.start();
                clankOsc.start(audioCtx.currentTime + clankDelay);
                motorOsc.stop(audioCtx.currentTime + duration);
                clankOsc.stop(audioCtx.currentTime + clankDelay + 0.1);
            }

            useEffect(() => {
                loadState();
            }, []);

            useEffect(() => {
                saveState();
            }, [player1Authority, player2Authority, player1Score, player2Score, player1Name, player2Name, gameHistory, gameOver, tableMode, player1Rotation, player2Rotation, lastMatchSummary, lastPlayer, player1CurrentTurnDamage, player2CurrentTurnDamage, player1CurrentTurnHeal, player2CurrentTurnHeal, player1HighestTurnDamage, player2HighestTurnDamage, player1HighestTurnHeal, player2HighestTurnHeal, player1Shields, player2Shields, player1ActiveShields, player2ActiveShields]);

            useEffect(() => {
                document.body.classList.toggle('table-mode', tableMode);
            }, [tableMode]);

            function saveState() {
                const state = {
                    player1Authority,
                    player2Authority,
                    player1Score,
                    player2Score,
                    player1Name,
                    player2Name,
                    player1Rotation,
                    player2Rotation,
                    gameHistory,
                    gameOver,
                    tableMode,
                    lastMatchSummary,
                    lastPlayer,
                    player1CurrentTurnDamage,
                    player2CurrentTurnDamage,
                    player1CurrentTurnHeal,
                    player2CurrentTurnHeal,
                    player1HighestTurnDamage,
                    player2HighestTurnDamage,
                    player1HighestTurnHeal,
                    player2HighestTurnHeal,
                    player1Shields,
                    player2Shields,
                    player1ActiveShields,
                    player2ActiveShields,
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            }

            function loadState() {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    try {
                        const state = JSON.parse(saved);
                        setPlayer1Authority(state.player1Authority ?? STARTING_AUTHORITY);
                        setPlayer2Authority(state.player2Authority ?? STARTING_AUTHORITY);
                        setPlayer1Score(state.player1Score ?? 0);
                        setPlayer2Score(state.player2Score ?? 0);
                        setPlayer1Name(state.player1Name ?? 'Player 1');
                        setPlayer2Name(state.player2Name ?? 'Player 2');
                        setPlayer1Rotation(state.player1Rotation ?? 0);
                        setPlayer2Rotation(state.player2Rotation ?? 0);
                        setGameHistory(state.gameHistory ?? []);
                        setGameOver(state.gameOver ?? false);
                        setTableMode(state.tableMode ?? false);
                        setLastMatchSummary(state.lastMatchSummary ?? '');
                        setLastPlayer(state.lastPlayer ?? 0);
                        setPlayer1CurrentTurnDamage(state.player1CurrentTurnDamage ?? 0);
                        setPlayer2CurrentTurnDamage(state.player2CurrentTurnDamage ?? 0);
                        setPlayer1CurrentTurnHeal(state.player1CurrentTurnHeal ?? 0);
                        setPlayer2CurrentTurnHeal(state.player2CurrentTurnHeal ?? 0);
                        setPlayer1HighestTurnDamage(state.player1HighestTurnDamage ?? 0);
                        setPlayer2HighestTurnDamage(state.player2HighestTurnDamage ?? 0);
                        setPlayer1HighestTurnHeal(state.player1HighestTurnHeal ?? 0);
                        setPlayer2HighestTurnHeal(state.player2HighestTurnHeal ?? 0);
                        setPlayer1Shields(state.player1Shields ?? [0, 0, 0, 0]);
                        setPlayer2Shields(state.player2Shields ?? [0, 0, 0, 0]);
                        setPlayer1ActiveShields(state.player1ActiveShields ?? [false, false, false, false]);
                        setPlayer2ActiveShields(state.player2ActiveShields ?? [false, false, false, false]);
                    } catch (e) {
                        console.error('Failed to load saved state:', e);
                    }
                }
            }

            function changeAuthority(player, amount) {
                if (gameOver && amount < 0) return;

                const timerRef = player === 1 ? player1TimerRef : player2TimerRef;
                
                if (timerRef.current) {
                    clearTimeout(timerRef.current);
                }

                if (amount < 0) {
                    if (player === 1) {
                        setPlayer1PendingDamage(prev => prev + Math.abs(amount));
                    } else {
                        setPlayer2PendingDamage(prev => prev + Math.abs(amount));
                    }
                } else if (amount > 0) {
                    if (player === 1) {
                        setPlayer1PendingHeal(prev => prev + amount);
                    } else {
                        setPlayer2PendingHeal(prev => prev + amount);
                    }
                }

                timerRef.current = setTimeout(() => {
                    const pendingDamage = player === 1 ? player1PendingDamage : player2PendingDamage;
                    const pendingHeal = player === 1 ? player1PendingHeal : player2PendingHeal;
                    
                    if (pendingDamage > 0) {
                        deliverAccumulatedDamage(player, -pendingDamage);
                    } else if (pendingHeal > 0) {
                        deliverAccumulatedDamage(player, pendingHeal);
                    }
                    
                    timerRef.current = null;
                }, 750);
            }

            function addHistory(message, player) {
                const item = {
                    message,
                    player,
                    time: new Date().toLocaleTimeString(),
                };
                setGameHistory(prev => {
                    const newHistory = [item, ...prev];
                    if (newHistory.length > 30) {
                        newHistory.pop();
                    }
                    return newHistory;
                });
            }

            function endGame(winnerNum) {
                setGameOver(true);
                const winnerName = winnerNum === 1 ? player1Name : player2Name;
                const loserName = winnerNum === 1 ? player2Name : player1Name;
                const winnerAuth = winnerNum === 1 ? player1Authority : player2Authority;
                
                const duration = gameStartTime ? Math.floor((Date.now() - gameStartTime) / 1000) : 0;
                const minutes = Math.floor(duration / 60);
                const seconds = duration % 60;
                const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                const finalWinnerTurnDamage = winnerNum === 1 ? player1CurrentTurnDamage : player2CurrentTurnDamage;
                const finalLoserTurnDamage = winnerNum === 1 ? player2CurrentTurnDamage : player1CurrentTurnDamage;
                const finalWinnerTurnHeal = winnerNum === 1 ? player1CurrentTurnHeal : player2CurrentTurnHeal;
                const finalLoserTurnHeal = winnerNum === 1 ? player2CurrentTurnHeal : player1CurrentTurnHeal;
                
                const winnerHighestTurnDamage = winnerNum === 1 
                    ? Math.max(player1HighestTurnDamage, player1CurrentTurnDamage) 
                    : Math.max(player2HighestTurnDamage, player2CurrentTurnDamage);
                const loserHighestTurnDamage = winnerNum === 1 
                    ? Math.max(player2HighestTurnDamage, player2CurrentTurnDamage) 
                    : Math.max(player1HighestTurnDamage, player1CurrentTurnDamage);
                const winnerHighestTurnHeal = winnerNum === 1 
                    ? Math.max(player1HighestTurnHeal, player1CurrentTurnHeal) 
                    : Math.max(player2HighestTurnHeal, player2CurrentTurnHeal);
                const loserHighestTurnHeal = winnerNum === 1 
                    ? Math.max(player2HighestTurnHeal, player2CurrentTurnHeal) 
                    : Math.max(player1HighestTurnHeal, player1CurrentTurnHeal);
                
                const winnerActiveShields = winnerNum === 1 
                    ? player1ActiveShields.filter(s => s).length 
                    : player2ActiveShields.filter(s => s).length;
                const loserActiveShields = winnerNum === 1 
                    ? player2ActiveShields.filter(s => s).length 
                    : player1ActiveShields.filter(s => s).length;
                
                const summary = generateMatchSummary(winnerName, winnerAuth, loserName, winnerHighestTurnDamage, loserHighestTurnDamage, winnerHighestTurnHeal, loserHighestTurnHeal, timeStr, winnerActiveShields, loserActiveShields);
                setLastMatchSummary(summary);

                if (winnerNum === 1) {
                    setPlayer1Score(prev => prev + 1);
                } else {
                    setPlayer2Score(prev => prev + 1);
                }

                addHistory(`${winnerName} wins!`, winnerNum);
                setWinner(winnerName);
                setWinnerAuthority(winnerAuth);
                setVideoKey(prev => prev + 1);
                setShowVideo(true);
                
                setPlayer1HighestDamage(0);
                setPlayer2HighestDamage(0);
                setPlayer1HighestHeal(0);
                setPlayer2HighestHeal(0);
                setPlayer1CurrentTurnDamage(0);
                setPlayer2CurrentTurnDamage(0);
                setPlayer1CurrentTurnHeal(0);
                setPlayer2CurrentTurnHeal(0);
                setPlayer1HighestTurnDamage(0);
                setPlayer2HighestTurnDamage(0);
                setPlayer1HighestTurnHeal(0);
                setPlayer2HighestTurnHeal(0);
                setLastPlayer(0);
                setGameStartTime(null);
            }

            function generateMatchSummary(winnerName, winnerAuth, loserName, winnerDmg, loserDmg, winnerHeal, loserHeal, timeStr, winnerActiveShields, loserActiveShields) {
                let msg = "";
                
                const winnerShieldMsg = winnerActiveShields > 0 ? `${winnerName} activated ${winnerActiveShields} shield${winnerActiveShields > 1 ? 's' : ''}! ` : '';
                const loserShieldMsg = loserActiveShields > 0 ? `${loserName} had ${loserActiveShields} active shield${loserActiveShields > 1 ? 's' : ''}. ` : '';
                
                if (winnerAuth >= 40) {
                    msg = `${winnerShieldMsg}${winnerName} DESTROYED ${loserName} with ${winnerDmg} damage on their best turn! ${winnerName} healed ${winnerHeal} at their best! Match lasted ${timeStr}! ${loserShieldMsg}${loserName} only managed ${loserDmg} damage - pathetic! ${winnerName} is a LEGEND! ${loserName} should be embarrassed!`;
                } else if (winnerAuth >= 25) {
                    msg = `${winnerShieldMsg}${winnerName} dominated with ${winnerDmg} damage combo! ${winnerName} healed ${winnerHeal} at peak! ${timeStr} match! ${loserShieldMsg}${loserName} only had ${loserDmg} damage - too weak! ${winnerName} wins! ${loserName} needs practice!`;
                } else if (winnerAuth >= 10) {
                    msg = `${winnerShieldMsg}${winnerName} secured the win with ${winnerDmg} damage strike! ${winnerName} popped ${winnerHeal} heal! ${timeStr} battle! ${loserShieldMsg}${loserName} had ${loserDmg} damage - should have done more! ${winnerName} takes glory!`;
                } else {
                    msg = `${winnerShieldMsg}${winnerName} BARELY SURVIVED with just ${winnerDmg} damage on the final blow! ${winnerName} healed ${winnerHeal} at their best! ${timeStr} of chaos! ${loserShieldMsg}${loserName} had ${loserDmg} damage - so close yet so far! ${winnerName} has NERVES OF STEEL!`;
                }
                
                return msg.substring(0, 500);
            }

            function getVictoryMessage(winnerName, authority) {
                if (authority >= 50) return `${winnerName} dominated.`;
                if (authority >= 40) return `${winnerName} was superior.`;
                if (authority >= 30) return `${winnerName} is victorious.`;
                if (authority >= 20) return `${winnerName} won that one.`;
                if (authority >= 10) return `${winnerName} got lucky.`;
                return `${winnerName} vant p√• fett h√•ret.`;
            }

            function resetGame() {
                if (newGameAudioRef.current) {
                    newGameAudioRef.current.currentTime = 0;
                    newGameAudioRef.current.play();
                }
                if (player1TimerRef.current) {
                    clearTimeout(player1TimerRef.current);
                    player1TimerRef.current = null;
                }
                if (player2TimerRef.current) {
                    clearTimeout(player2TimerRef.current);
                    player2TimerRef.current = null;
                }
                setPlayer1Authority(STARTING_AUTHORITY);
                setPlayer2Authority(STARTING_AUTHORITY);
                setGameOver(false);
                setWinner(null);
                setWinnerAuthority(0);
                setShowVideo(false);
                setPlayer1CurrentTurnDamage(0);
                setPlayer2CurrentTurnDamage(0);
                setPlayer1CurrentTurnHeal(0);
                setPlayer2CurrentTurnHeal(0);
                setPlayer1HighestTurnDamage(0);
                setPlayer2HighestTurnDamage(0);
                setPlayer1HighestTurnHeal(0);
                setPlayer2HighestTurnHeal(0);
                setPlayer1Shields([0, 0, 0, 0]);
                setPlayer2Shields([0, 0, 0, 0]);
                setPlayer1ActiveShields([false, false, false, false]);
                setPlayer2ActiveShields([false, false, false, false]);
                setPlayer1PendingDamage(0);
                setPlayer2PendingDamage(0);
                setPlayer1PendingHeal(0);
                setPlayer2PendingHeal(0);
                setLastPlayer(0);
                setGameStartTime(null);
                addHistory('--- New Game ---', 0);
            }

            function resetScore() {
                setPlayer1Score(0);
                setPlayer2Score(0);
            }

            function toggleTableMode() {
                setTableMode(prev => !prev);
            }

            function toggleMenu() {
                setShowMenu(prev => !prev);
            }

            function rotatePlayer(player) {
                if (player === 1) {
                    setPlayer1Rotation(prev => (prev + 90) % 360);
                } else {
                    setPlayer2Rotation(prev => (prev + 90) % 360);
                }
            }

            function closeVictoryAndReset() {
                setWinner(null);
                resetGame();
            }

            function getAuthorityClass(value) {
                if (value <= 10) return 'danger';
                if (value <= 20) return 'warning';
                return '';
            }

            function setShield(player, shieldIndex) {
                const input = prompt('Enter shield value (0-10):');
                const value = parseInt(input, 10);
                if (isNaN(value) || value < 0 || value > 10) return;
                
                const name = player === 1 ? player1Name : player2Name;
                
                if (player === 1) {
                    const wasActive = player1ActiveShields[shieldIndex];
                    setPlayer1Shields(prev => {
                        const newShields = [...prev];
                        newShields[shieldIndex] = value;
                        return newShields;
                    });
                    if (value > 0 && !wasActive) {
                        setPlayer1ActiveShields(prev => {
                            const newActive = [...prev];
                            newActive[shieldIndex] = true;
                            return newActive;
                        });
                    }
                    if (value > 0) {
                        addHistory(`${name}: Shield ${shieldIndex + 1} = ${value}`, 1);
                    }
                } else {
                    const wasActive = player2ActiveShields[shieldIndex];
                    setPlayer2Shields(prev => {
                        const newShields = [...prev];
                        newShields[shieldIndex] = value;
                        return newShields;
                    });
                    if (value > 0 && !wasActive) {
                        setPlayer2ActiveShields(prev => {
                            const newActive = [...prev];
                            newActive[shieldIndex] = true;
                            return newActive;
                        });
                    }
                    if (value > 0) {
                        addHistory(`${name}: Shield ${shieldIndex + 1} = ${value}`, 2);
                    }
                }
            }

            function deliverAccumulatedDamage(player, amount) {
                if (amount === 0) return;
                
                if (gameStartTime === null && amount < 0) {
                    setGameStartTime(Date.now());
                }

                let remainingDamage = 0;
                let shieldsToUpdate = [];
                let destroyedShields = [];

                if (amount < 0) {
                    playLaserSound(amount);
                    const damage = Math.abs(amount);
                    const currentShields = player === 1 ? player1Shields : player2Shields;
                    
                    let currentDamage = damage;
                    const newShields = [...currentShields];
                    
                    while (currentDamage > 0) {
                        const eligibleShields = newShields
                            .map((v, i) => ({ value: v, index: i }))
                            .filter(s => s.value > 0 && s.value <= currentDamage);
                        
                        if (eligibleShields.length === 0) break;
                        
                        const highest = eligibleShields.reduce((max, s) => s.value > max.value ? s : max, eligibleShields[0]);
                        destroyedShields.push({ index: highest.index, value: highest.value });
                        currentDamage -= highest.value;
                        newShields[highest.index] = 0;
                    }
                    
                    remainingDamage = currentDamage;
                    shieldsToUpdate = newShields;
                    
                    if (player === 1) {
                        setPlayer1Shields(newShields);
                        if (lastPlayer !== 1 && lastPlayer !== 0) {
                            setPlayer2HighestTurnDamage(prev => Math.max(prev, player2CurrentTurnDamage));
                            setPlayer2HighestTurnHeal(prev => Math.max(prev, player2CurrentTurnHeal));
                            setPlayer2CurrentTurnDamage(0);
                            setPlayer2CurrentTurnHeal(0);
                        }
                        setPlayer2CurrentTurnDamage(prev => prev + damage);
                        setPlayer1HighestDamage(prev => Math.max(prev, damage));
                    } else {
                        setPlayer2Shields(newShields);
                        if (lastPlayer !== 2 && lastPlayer !== 0) {
                            setPlayer1HighestTurnDamage(prev => Math.max(prev, player1CurrentTurnDamage));
                            setPlayer1HighestTurnHeal(prev => Math.max(prev, player1CurrentTurnHeal));
                            setPlayer1CurrentTurnDamage(0);
                            setPlayer1CurrentTurnHeal(0);
                        }
                        setPlayer1CurrentTurnDamage(prev => prev + damage);
                        setPlayer2HighestDamage(prev => Math.max(prev, damage));
                    }
                } else if (amount > 0) {
                    playWorkshopSound(amount);
                    if (player === 1) {
                        if (lastPlayer !== 1 && lastPlayer !== 0) {
                            setPlayer1HighestTurnDamage(prev => Math.max(prev, player1CurrentTurnDamage));
                            setPlayer1HighestTurnHeal(prev => Math.max(prev, player1CurrentTurnHeal));
                            setPlayer1CurrentTurnDamage(0);
                            setPlayer1CurrentTurnHeal(0);
                        }
                        setPlayer1CurrentTurnHeal(prev => prev + amount);
                        setPlayer1HighestHeal(prev => Math.max(prev, amount));
                    } else {
                        if (lastPlayer !== 2 && lastPlayer !== 0) {
                            setPlayer2HighestTurnDamage(prev => Math.max(prev, player2CurrentTurnDamage));
                            setPlayer2HighestTurnHeal(prev => Math.max(prev, player2CurrentTurnHeal));
                            setPlayer2CurrentTurnDamage(0);
                            setPlayer2CurrentTurnHeal(0);
                        }
                        setPlayer2CurrentTurnHeal(prev => prev + amount);
                        setPlayer2HighestHeal(prev => Math.max(prev, amount));
                    }
                }

                if (player === 1) {
                    setPlayer1PendingDamage(0);
                    setPlayer1PendingHeal(0);
                } else {
                    setPlayer2PendingDamage(0);
                    setPlayer2PendingHeal(0);
                }

                const shieldsToCheck = shieldsToUpdate.length > 0 ? shieldsToUpdate : (player === 1 ? player1Shields : player2Shields);
                const allShieldsInactive = shieldsToCheck.every(s => s === 0);
                
                let finalAmount = 0;
                if (amount > 0 || allShieldsInactive) {
                    finalAmount = amount < 0 ? -remainingDamage : amount;
                }

                destroyedShields.forEach(shield => {
                    const playerName = player === 1 ? player2Name : player1Name;
                    const historyPlayer = player === 1 ? 2 : 1;
                    addHistory(`${playerName}: Shield ${shield.index + 1} blocked ${shield.value} damage`, historyPlayer);
                });

                setLastPlayer(player);

                const name = player === 1 ? player1Name : player2Name;

                if (player === 1) {
                    const newValue = Math.max(0, player1Authority + finalAmount);
                    setPlayer1Authority(newValue);
                    if (finalAmount !== 0) {
                        addHistory(`${name}: ${finalAmount < 0 ? finalAmount : '+' + finalAmount}`, 1);
                    }

                    if (newValue <= 0) {
                        endGame(2);
                    }
                } else {
                    const newValue = Math.max(0, player2Authority + finalAmount);
                    setPlayer2Authority(newValue);
                    if (finalAmount !== 0) {
                        addHistory(`${name}: ${finalAmount < 0 ? finalAmount : '+' + finalAmount}`, 2);
                    }

                    if (newValue <= 0) {
                        endGame(1);
                    }
                }
            }

            return (
                <>
                    <audio ref={newGameAudioRef} src="simple/Sound/_O.wav" preload="auto" />
                    <audio ref={minusOneSoundRef} src="simple/Sound/Dy.wav" preload="auto" />
                    <audio ref={minusFiveSoundRef} src="simple/Sound/D61.wav" preload="auto" />
                    <audio ref={minusTenSoundRef} src="simple/Sound/L2.wav" preload="auto" />
                    <audio ref={minusTwentySoundRef} src="simple/Sound/bw.wav" preload="auto" />
                    <audio ref={plusOneSoundRef} src="simple/Sound/D6.wav" preload="auto" />
                    <audio ref={plusFiveFirstSoundRef} src="simple/Sound/bA.wav" preload="auto" />
                    <audio ref={plusFiveSecondSoundRef} src="simple/Sound/D6.wav" preload="auto" />
                    <div className="container">
                        <div className="game-board">
                            <div 
                                className={`player player-1 ${gameOver ? 'defeated' : ''}`}
                                style={{ transform: `rotate(${player1Rotation}deg)` }}
                            >
                                <div className="player-header">
                                    <button 
                                        className="btn btn-rotate" 
                                        onClick={() => rotatePlayer(1)}
                                        title="Rotate 90¬∞"
                                    >‚Üª</button>
                                    <div className="shields">
                                        {[0, 1, 2, 3].map(i => (
                                            <button 
                                                key={i}
                                                className={`btn btn-shield ${player1Shields[i] > 0 ? 'active' : ''}`}
                                                onClick={() => setShield(1, i)}
                                                title={`Shield ${i + 1}`}
                                            >{player1Shields[i] > 0 ? player1Shields[i] : 'üõ°Ô∏è'}</button>
                                        ))}
                                    </div>
                                    {player1PendingDamage > 0 && <div className="pending-damage">Pending: -{player1PendingDamage}</div>}
                                    {player1PendingHeal > 0 && <div className="pending-heal">Pending: +{player1PendingHeal}</div>}
                                    <input
                                        type="text"
                                        className="player-name"
                                        value={player1Name}
                                        onChange={(e) => setPlayer1Name(e.target.value)}
                                        maxLength={12}
                                    />
                                    <div className="score-mini">
                                        <span>{player1Score}</span> wins
                                    </div>
                                </div>
                                <div className="authority-area">
                                    <div className="controls-damage">
                                        <button className="btn btn-damage" onClick={() => changeAuthority(1, -20)}>-20</button>
                                        <button className="btn btn-damage" onClick={() => changeAuthority(1, -10)}>-10</button>
                                        <button className="btn btn-damage" onClick={() => changeAuthority(1, -5)}>-5</button>
                                        <button className="btn btn-damage" onClick={() => changeAuthority(1, -1)}>-1</button>
                                    </div>
                                    <div className="authority-display">
                                        <div className={`authority-value ${getAuthorityClass(player1Authority)}`}>
                                            {player1Authority}
                                        </div>
                                        <div className="authority-label">AUTHORITY</div>
                                    </div>
                                    <div className="controls-heal">
                                        <button className="btn btn-heal" onClick={() => changeAuthority(1, 1)}>+1</button>
                                        <button className="btn btn-heal" onClick={() => changeAuthority(1, 5)}>+5</button>
                                    </div>
                                </div>
                            </div>

                            <header>
                                <h1>Star Realms</h1>
                                <div className="header-controls">
                                    <button 
                                        className="btn btn-icon" 
                                        onClick={() => alert(lastMatchSummary)}
                                        title="Match Summary"
                                        disabled={!lastMatchSummary}
                                    >üì¢</button>
                                    <button
                                        className={`btn btn-icon ${tableMode ? 'active' : ''}`}
                                        onClick={toggleTableMode}
                                        title="Table Mode"
                                    >üì±</button>
                                    <button className="btn btn-icon" onClick={toggleMenu} title="Menu">‚öôÔ∏è</button>
                                </div>
                            </header>

                            <div 
                                className={`player player-2 ${gameOver ? 'defeated' : ''}`}
                                style={{ transform: `rotate(${player2Rotation}deg)` }}
                            >
                                <div className="player-header">
                                    <button 
                                        className="btn btn-rotate" 
                                        onClick={() => rotatePlayer(2)}
                                        title="Rotate 90¬∞"
                                    >‚Üª</button>
                                    <div className="shields">
                                        {[0, 1, 2, 3].map(i => (
                                            <button 
                                                key={i}
                                                className={`btn btn-shield ${player2Shields[i] > 0 ? 'active' : ''}`}
                                                onClick={() => setShield(2, i)}
                                                title={`Shield ${i + 1}`}
                                            >{player2Shields[i] > 0 ? player2Shields[i] : 'üõ°Ô∏è'}</button>
                                        ))}
                                    </div>
                                    {player2PendingDamage > 0 && <div className="pending-damage">Pending: -{player2PendingDamage}</div>}
                                    {player2PendingHeal > 0 && <div className="pending-heal">Pending: +{player2PendingHeal}</div>}
                                    <input
                                        type="text"
                                        className="player-name"
                                        value={player2Name}
                                        onChange={(e) => setPlayer2Name(e.target.value)}
                                        maxLength={12}
                                    />
                                    <div className="score-mini">
                                        <span>{player2Score}</span> wins
                                    </div>
                                </div>
                                <div className="authority-area">
                                    <div className="controls-damage">
                                        <button className="btn btn-damage" onClick={() => changeAuthority(2, -20)}>-20</button>
                                        <button className="btn btn-damage" onClick={() => changeAuthority(2, -10)}>-10</button>
                                        <button className="btn btn-damage" onClick={() => changeAuthority(2, -5)}>-5</button>
                                        <button className="btn btn-damage" onClick={() => changeAuthority(2, -1)}>-1</button>
                                    </div>
                                    <div className="authority-display">
                                        <div className={`authority-value ${getAuthorityClass(player2Authority)}`}>
                                            {player2Authority}
                                        </div>
                                        <div className="authority-label">AUTHORITY</div>
                                    </div>
                                    <div className="controls-heal">
                                        <button className="btn btn-heal" onClick={() => changeAuthority(2, 1)}>+1</button>
                                        <button className="btn btn-heal" onClick={() => changeAuthority(2, 5)}>+5</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className={`menu-panel ${showMenu ? 'show' : ''}`}>
                            <button className="btn btn-reset" onClick={resetGame}>New Game</button>
                            <button className="btn btn-small" onClick={resetScore}>Reset Score</button>
                            <div className="history">
                                <h3>Game History</h3>
                                <div className="history-list">
                                    {gameHistory.map((item, index) => (
                                        <div
                                            key={index}
                                            className={`history-item ${
                                                item.player === 1 ? 'player-1-action' :
                                                item.player === 2 ? 'player-2-action' : ''
                                            }`}
                                        >
                                            <span>{item.message}</span>
                                            <span>{item.time}</span>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className={`victory-overlay ${winner ? 'show' : ''}`}>
                        {showVideo && (
                            <video 
                                className="explosion-video"
                                autoPlay
                                playsInline
                                key={videoKey}
                            >
                                <source src="Spaceship_Explosion_GIF_Generation.mp4" type="video/mp4" />
                            </video>
                        )}
                        <div className="victory-content">
                            <div className="victory-text">{winner ? getVictoryMessage(winner, winnerAuthority) : ''}</div>
                            <button className="btn btn-reset" onClick={closeVictoryAndReset}>New Game</button>
                        </div>
                    </div>
                </>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
